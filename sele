#!/usr/bin/awk -E
#https://github.com/ryandward/sele
BEGIN {

  PROCINFO["sorted_in"] = "@ind_num_asc"

  for( i = 1; i <= ARGC; i++ ) {
    if( substr( ARGV[i], 1, 1 ) != "-" )
    break;
    if( ARGV[i] == "-c" ) {
      column = ARGV[i+1];
      i++;
      continue;
    }

    if( ARGV[i] == "-q" ) {
      quiet = 1;
      continue;
    }

    if( ARGV[i] == "-s" ) {
      set = ARGV[i+1];
      i++;
      continue;
    }

    if( ARGV[i] == "-w" ) {
      where = ARGV[i+1];
      i++;
      continue;
    }

    printf("Unrecognized option: %s\n", ARGV[i] ) >"/dev/stderr";
    exit(1);
  }

  j = 1; c = 1;
  for( i; i < ARGC; i++ ) {
    ARGV[j++] = ARGV[i];
    c++;
  }

  ARGC = c;

  FS="\t";
  OFS="\t";
  # FPAT="[^,\"]*|\"([^\"]|\"\")*\""


  if(column!=""){
    clen = split(toupper(column),Column,",");
    for(i in Column){
      Node_index[Column[i]]
    }
  }

  split(toupper(where),Where,",");
  split(set,Set,",");

  for(i in Where) {

    if(index(Where[i],"==")){
      split(Where[i],subj_pred,"==")
      Where_map[subj_pred[1]]=subj_pred[2]
      Operator[subj_pred[1]]="=="
    }

    else if(index(Where[i],"!=")){
      split(Where[i],subj_pred,"!=")
      Where_map[subj_pred[1]]=subj_pred[2]
      Operator[subj_pred[1]]="!="
    }

    else if(index(Where[i],"!~")){
      split(Where[i],subj_pred,"!~")
      Where_map[subj_pred[1]]=subj_pred[2]
      Operator[subj_pred[1]]="!~"
    }

    else if(index(Where[i],"~")){
      split(Where[i],subj_pred,"~")
      Where_map[subj_pred[1]]=subj_pred[2]
      Operator[subj_pred[1]]="~"
    }

    else if(index(Where[i],">=")){
      split(Where[i],subj_pred,">=")
      Where_map[subj_pred[1]]=subj_pred[2]
      Operator[subj_pred[1]]=">="
    }

    else if(index(Where[i],"<=")){
      split(Where[i],subj_pred,"<=")
      Where_map[subj_pred[1]]=subj_pred[2]
      Operator[subj_pred[1]]="<="
    }

    else if(index(Where[i],">")){
      split(Where[i],subj_pred,">")
      Where_map[subj_pred[1]]=subj_pred[2]
      Operator[subj_pred[1]]=">"
    }

    else if(index(Where[i],"<")){
      split(Where[i],subj_pred,"<")
      Where_map[subj_pred[1]]=subj_pred[2]
      Operator[subj_pred[1]]="<"
    }

    else {
      printf("Invalid lookup condition character\n" ) >"/dev/stderr";
      exit(1);
    }
  }

    for(i in Set) {
      if(index(Set[i],"==")){
        printf("Invalid update character\n" ) >"/dev/stderr";
        exit(1);
      }
      else if(index(Set[i],"=")){
        split(Set[i],subj_pred,"=")
        Set_map[toupper(subj_pred[1])]=subj_pred[2]
      }
      else {
        printf("Invalid update character, use =\n" ) >"/dev/stderr";
        exit(1);
      }
    }
}

NR == 1 {
  for (i=1; i<=NF; i++) {
    Node_index[toupper($i)] = i
    Node_map[i] = $i
    if(!column){
      clen++;
      Column[i]=toupper($i);
    }
  }

  for (i in Column) {
    if(!Node_index[Column[i]]){
      printf("Unrecognized query column: %s\n", Column[i]) > "/dev/stderr" ; exit(1) }}

  for(i in Where_map){
    if(!(i in Node_index)) {
      printf("Unrecognized where column: %s\n", i) > "/dev/stderr" ; exit(1) }}

  for(i in Set_map){
    if(!(i in Node_index)) {
      printf("Unrecognized update column: %s\n", i) > "/dev/stderr" ; exit(1) }}

}

NR > 1 && where {
  for(i in Where_map) {
    if (NR in stop) next
    else {
      switch (Operator[i]){
        case "==":
          if (toupper($Node_index[i]) == Where_map[i]) continue
          break

        case "!=":
          if (toupper($Node_index[i]) != Where_map[i]) continue
          break

        case "~":
          if (toupper($Node_index[i]) ~ Where_map[i]) continue
          break

        case "!~":
          if (toupper($Node_index[i]) !~ Where_map[i]) continue
          break

        case ">=":
          # $Node_index[i] = $Node_index[i] + 0
          if ($Node_index[i] + 0 >= Where_map[i] + 0) continue
          break

        case "<=":
          # $Node_index[i] = $Node_index[i] + 0
          if ($Node_index[i] + 0 <= Where_map[i] + 0) continue
          break

        case ">":
          # $Node_index[i] = $Node_index[i] + 0
          if ($Node_index[i] + 0 > Where_map[i] + 0) continue
          break

        case "<":
          # $Node_index[i] = $Node_index[i] + 0
          if ($Node_index[i] + 0 < Where_map[i] + 0) continue
          break
      }
    }
    stop[NR]
  }

  if(set)
    for(i in Set_map)
      $Node_index[i] = Set_map[i]

  }

(!(NR in stop)) {

  if (quiet && FNR == 1) next
  for (i in Column)
    printf $Node_index[Column[i]] (i + 0 < clen + 0 ? OFS : ORS)
}
